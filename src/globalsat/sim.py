"""
Globalsat simulation model.

Developed by Bonface Osaro and Ed Oughton.

December 2020

"""
import math
import numpy as np

def system_capacity(constellation, number_of_satellites, params):
    """
    Find the system capacity.

    Parameters
    ----------
    constellation : string
        Consetellation selected for assessment.
    number_of_satellites : int
        Number of satellites in the contellation being simulated.
    params : dict
        Contains all simulation parameters.

    Returns
    -------
    results : list of dicts
        System capacity results generated by the simulation.

    """
    results = []

    distance, satelite_coverage_area = calc_geographic_metrics(number_of_satellites, params)

    random_variations = generate_log_normal_dist_value(
            params['dl_frequency'],
            params['mu'],
            params['sigma'],
            params['seed_value'],
            params['iterations']
        )

    for i in range(0, params['iterations']):

        path_loss = calc_free_space_path_loss(distance, params, i, random_variations)

        antenna_gain = calc_antenna_gain(
            params['speed_of_light'],
            params['antenna_diameter'],
            params['dl_frequency'],
            params['antenna_efficiency']
        )

        eirp = calc_eirp(params['power'], antenna_gain, params['losses'])

        received_power = calc_received_power(eirp, path_loss)

        noise = calc_noise()

        cnr = calc_cnr(received_power, noise)

        spectral_efficiency = calc_spectral_efficiency(cnr)

        capacity = calc_capacity(spectral_efficiency, params['dl_bandwidth'])

        results.append({
            'constellation': constellation,
            'number_of_satellites': number_of_satellites,
            'distance': distance,
            'satelite_coverage_area': satelite_coverage_area,
            'iteration': i,
            'path_loss': path_loss,
            'antenna_gain': antenna_gain,
            'eirp': eirp,
            'received_power': received_power,
            'noise': noise,
            'cnr': cnr,
            'spectral_efficiency': spectral_efficiency,
            'capacity': capacity,
            'capacity_kmsq': capacity / satelite_coverage_area,
        })

    return results


def calc_geographic_metrics(number_of_satellites, params):
    """
    Calculate geographic metrics, including (i) the distance between the transmitter
    and reciever, and (ii) the coverage area for each satellite.

    Parameters
    ----------
    number_of_satellites : int
        Number of satellites in the contellation being simulated.
    params : dict
        Contains all simulation parameters.

    Returns
    -------
    distance : float
        The distance between the transmitter and reciever in km.
    satelite_coverage_area : float
        The area which each satellite covers on Earth's surface in km.

    """
    area_of_earth_covered = (
        params['total_area_earth_km_sq'] *
        params['portion_of_earth_covered']
    )

    network_density = number_of_satellites / area_of_earth_covered

    satelite_coverage_area = (area_of_earth_covered / number_of_satellites)

    mean_distance_between_assets = math.sqrt((1 / network_density)) / 2

    distance = math.sqrt(((mean_distance_between_assets)**2) + ((params['altitude_km'])**2))

    return distance, satelite_coverage_area


def calc_free_space_path_loss(distance, params, i, random_variations):
    """
    Calculate the free space path loss in decibels.

    FSPL(dB) = 20log(d) + 20log(f) + 32.44

    Where distance (d) is in km and frequency (f) is MHz.

    Parameters
    ----------
    distance : float
        Distance between transmitter and receiver in metres.
    params : dict
        Contains all simulation parameters.
    i : int
        Iteration number.
    random_variation : list
        List of random variation components.

    Returns
    -------
    path_loss : float
        The free space path loss over the given distance.

    """
    frequency_MHz = params['dl_frequency'] / 1e6

    path_loss = 20*math.log10(distance) + 20*math.log10(frequency_MHz) + 32.44

    random_variation = random_variations[i]

    return path_loss + random_variation


def generate_log_normal_dist_value(frequency, mu, sigma, seed_value, draws):
    """
    Generates random values using a lognormal distribution, given a specific mean (mu)
    and standard deviation (sigma).

    Original function in pysim5G/path_loss.py.

    The parameters mu and sigma in np.random.lognormal are not the mean and STD of the
    lognormal distribution. They are the mean and STD of the underlying normal distribution.

    Parameters
    ----------
    frequency : float
        Carrier frequency value in Hertz.
    mu : int
        Mean of the desired distribution.
    sigma : int
        Standard deviation of the desired distribution.
    seed_value : int
        Starting point for pseudo-random number generator.
    draws : int
        Number of required values.

    Returns
    -------
    random_variation : float
        Mean of the random variation over the specified itations.

    """
    if seed_value == None:
        pass
    else:
        frequency_seed_value = seed_value * frequency * 100
        np.random.seed(int(str(frequency_seed_value)[:2]))

    normal_std = np.sqrt(np.log10(1 + (sigma/mu)**2))
    normal_mean = np.log10(mu) - normal_std**2 / 2

    random_variation  = np.random.lognormal(normal_mean, normal_std, draws)

    return random_variation


def calc_antenna_gain(c, d, f, n):
    """
    Calculates the antenna gain.

    Parameters
    ----------
    c : float
        Speed of light in m/s.
    d : float
        Antenna diameter in meters.
    f : int
        Carrier frequency in Hertz.
    n : float
        Antenna efficiency.

    Returns
    -------
    antenna_gain : float
        Antenna gain in dB.

    """
    #Define signal wavelength
    lambda_wavelength = c / f

    #Calculate antenna_gain
    antenna_gain = 10 * (math.log10(n*((np.pi*d) / lambda_wavelength)**2))

    return antenna_gain


def calc_eirp(power, antenna_gain, losses):
    """
    Calculate the Equivalent Isotropically Radiated Power.

    Equivalent Isotropically Radiated Power (EIRP) = (
        Power + Gain - Losses
    )

    Parameters
    ----------
    power : float
        Transmitter power in watts.
    antenna_gain : float
        Antenna gain in dB.
    losses : float
        Antenna losses in dB.

    Returns
    -------
    eirp : float
        eirp in dB.

    """
    eirp = power + antenna_gain - losses

    return eirp


def calc_received_power(eirp, path_loss):
    """

    Parameters
    ----------
    eirp : float
        eirp in dB.
    path_loss : float
        The free space path loss over the given distance.

    Returns
    -------
    received_power : float
        The received power at the receiver in dB.

    """
    receiver_gain = 4 # dummy values
    receiver_loss = 4 # dummy values

    received_power = eirp - path_loss + receiver_gain - receiver_loss

    return received_power


def calc_noise():
    """
    Estimates the potential noise.

    Terminal noise can be calculated as:

    “K (Boltzmann constant) x T (290K) x bandwidth”.

    The bandwidth depends on bit rate, which defines the number
    of resource blocks. We assume 50 resource blocks, equal 9 MHz,
    transmission for 1 Mbps downlink.

    Required SNR (dB)
    Detection bandwidth (BW) (Hz)
    k = Boltzmann constant
    T = Temperature (Kelvins) (290 Kelvin = ~16 degrees celcius)
    NF = Receiver noise figure (dB)

    NoiseFloor (dBm) = 10log10(k * T * 1000) + NF + 10log10BW

    NoiseFloor (dBm) = (
        10log10(1.38 x 10e-23 * 290 * 1x10e3) + 1.5 + 10log10(10 x 10e6)
    )

    Parameters
    ----------
    bandwidth : int
        The bandwidth of the carrier frequency (MHz).

    Returns
    -------
    noise : float
        Received noise at the UE receiver in decibels

    """
    k = 1.38e-23 #Boltzmann's constant k = 1.38×10−23 joules per kelvin
    t = 290 #Temperature of the receiver system T0 in kelvins
    b = 0.25 #Detection bandwidth (BW) in Hz

    noise = (10*(math.log10((k*t*1000)))) + (10*(math.log10(b*10**9)))

    return noise


def calc_cnr(received_power, noise):
    """
    Calculate the Carrier-to-Noise Ratio (CNR).

    Returns
    -------
    received_power : float
        The received power at the receiver in dB.
    noise : float
        Received noise at the UE receiver in decibels

    Returns
    -------
    cnr : float
        Carrier-to-Noise Ratio (CNR) in dB.

    """
    cnr = received_power - noise

    return cnr


def calc_spectral_efficiency(cnr):
    """
    Given a cnr, find the spectral efficnecy.

    Parameters
    ----------
    cnr : float
        Carrier-to-Noise Ratio (CNR) in dB.

    Returns
    -------
    spectral_efficiency : float
        The number of bits per Hertz able to be transmitted.

    """

    if cnr < 5.12:
        spectral_efficiency = 1.647211
    elif (cnr >= 5.13 and cnr < 5.96):
        spectral_efficiency = 1.972253
    elif (cnr >= 5.97 and cnr < 6.54):
        spectral_efficiency = 1.972253
    elif (cnr >= 6.55 and cnr < 6.83):
        spectral_efficiency = 2.104850
    elif (cnr >= 6.84 and cnr < 7.5):
        spectral_efficiency = 2.193247
    elif (cnr >= 7.51 and cnr < 7.79):
        spectral_efficiency = 2.281645
    elif (cnr >= 7.8 and cnr < 7.40):
        spectral_efficiency = 2.370043
    elif (cnr >= 7.41 and cnr < 8.0):
        spectral_efficiency = 2.370043
    elif (cnr >= 8.1 and cnr < 8.37):
        spectral_efficiency = 2.458441
    elif (cnr >= 8.38 and cnr < 8.42):
        spectral_efficiency = 2.524739
    elif (cnr >= 8.43 and cnr < 9.26):
        spectral_efficiency = 2.635236
    elif (cnr >= 9.27 and cnr < 9.70):
        spectral_efficiency = 2.745734
    elif (cnr >= 9.71 and cnr < 10.64):
        spectral_efficiency = 2.856231
    elif (cnr >= 10.65 and cnr < 11.98):
        spectral_efficiency = 3.077225
    elif (cnr >= 11.99 and cnr < 11.09):
        spectral_efficiency = 3.386618
    elif (cnr >= 11.1 and cnr < 11.74):
        spectral_efficiency = 3.291954
    elif (cnr >= 11.75 and cnr < 12.16):
        spectral_efficiency = 3.510192
    elif (cnr >= 12.17 and cnr < 13.04):
        spectral_efficiency = 3.620536
    elif (cnr >= 13.05 and cnr < 13.97):
        spectral_efficiency = 3.841226
    elif (cnr >= 13.98 and cnr < 14.8):
        spectral_efficiency = 4.206428
    elif (cnr >= 14.81 and cnr < 15.46):
        spectral_efficiency = 4.338659
    elif (cnr >= 15.47 and cnr < 15.86):
        spectral_efficiency = 4.603122
    elif (cnr >= 15.87 and cnr < 16.54):
        spectral_efficiency = 4.735354
    elif (cnr >= 16.55 and cnr < 17.72):
        spectral_efficiency = 4.936639
    elif (cnr >= 17.73 and cnr < 18.52):
        spectral_efficiency = 5.163248
    elif (cnr >= 18.53 and cnr < 16.97):
        spectral_efficiency = 5.355556
    elif (cnr >= 16.98 and cnr < 17.23):
        spectral_efficiency = 5.065690
    elif (cnr >= 17.24 and cnr < 18.0):
        spectral_efficiency = 5.241514
    elif (cnr >= 18.1 and cnr < 18.58):
        spectral_efficiency = 5.417338
    elif (cnr >= 18.59 and cnr < 18.83):
        spectral_efficiency = 5.593162
    elif (cnr >= 18.84 and cnr < 19.56):
        spectral_efficiency = 5.768987
    elif (cnr >= 19.57):
        spectral_efficiency = 5.900855
    else:
        print('Could not determine cnr to spectral efficinecy')

    return spectral_efficiency


def calc_capacity(spectral_efficiency, dl_bandwidth):
    """
    Calculate the channel capacity.

    Parameters
    ----------
    spectral_efficiency : float
        The number of bits per Hertz able to be transmitted.
    dl_bandwidth: float
        The channel bandwidth in Hetz.

    Returns
    -------
    capacity : float
        The channel capacity in Mbps.

    """
    capacity = spectral_efficiency * dl_bandwidth / (10**6)

    return capacity
